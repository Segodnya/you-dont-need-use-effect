# Content

## **Презентация: useEffect - когда он нужен, а когда нет**

### **Слайд 1: Введение**

Сколько раз вы писали useEffect за последнюю неделю? А сколько из них были действительно необходимы? Сегодня мы поговорим об одном из самых мощных, но, возможно, самом злоупотребляемом хуке в React - useEffect.

Мы часто используем его как универсальный молоток для любых задач, не связанных напрямую с рендерингом. Но на самом деле, во многих случаях useEffect не только не нужен, но и создает скрытые проблемы с производительностью, рождает баги и делает код запутанным.

Ключевой тезис: useEffect — это аварийный люк. Он нужен для 'побега' из React-парадигмы и синхронизации с внешними системами. Если вы используете его для управления внутренним состоянием вашего приложения — вы, скорее всего, делаете что-то не так.

### **Слайд 2: Вдохновение**

Вдохновился я на нынешний доклад после прочтения статьи:

- You Might Not Need an Effect - https://react.dev/learn/you-might-not-need-an-effect

Также по теме может быть полезно почитать непосредственно саму доку Реакта:

- Synchronizing with Effects - https://react.dev/learn/synchronizing-with-effects
- Separating Events from Effects - https://react.dev/learn/separating-events-from-effects
- Lifecycle of Reactive Effects - https://react.dev/learn/lifecycle-of-reactive-effects

### **Слайд 3: Что такое useEffect?**

Прежде чем ругать, давайте договоримся, для чего он создан. useEffect — это инструмент для синхронизации. Синхронизации вашего React-компонента с чем-то внешним по отношению к React.

Что такое 'внешняя система'?

- API браузера: setInterval, addEventListener, document.title
- Сетевые запросы (когда нет специализированной библиотеки)
- Сторонние библиотеки: Backbone, D3, Vanilla JS-виджеты, карты
- Подписки на данные (WebSocket, Firebase)

А что НЕ является внешней системой?

- Пропсы и состояние вашего же приложения
- Логика преобразования данных (фильтрация, сортировка)
- Обновление состояния на основе другого состояния

React уже имеет встроенный механизм реагирования на изменения — это сам рендер. useEffect — это ответ на изменения, которые выходят за рамки этого механизма.

### **Слайд 4: Проблемы неправильного использования useEffect**

Почему это так важно? Потому что цена ошибки высока.

1. Производительность: Каждый эффект — это потенциально лишний рендер. Представьте цепочку: Рендер -> Эффект -> setState -> Рендер... И так по кругу.
2. Баги: Race conditions в запросах данных, бесконечные циклы обновлений, состояние, которое 'прыгает' и не соответствует ожиданиям.
3. Сложность: Код с эффектами становится императивным. Мы говорим 'как' сделать, а не 'что' мы хотим видеть. Это сложнее отлаживать и понимать.
4. Архитектура: Мы нарушаем односторонний поток данных. Данные начинают течь снизу вверх через эффекты, создавая спагетти-код.

Давайте посмотрим на конкретные антипаттерны, которые хотелось бы искоренить.

### **Слайд 5: Ключевые сообщения для команды**

Основные идеи, которые хотелось бы сегодня донести:

1. "Effects are for synchronization, not for flow control" — эффекты для синхронизации с внешним миром, а не для управления потоком данных внутри приложения.
2. "Calculate during render" — вычисляйте всё, что можно, прямо во время рендера.
3. "React knows when state changes" — React и так знает, когда состояние изменилось, не нужно дублировать эту логику в эффектах.
4. "Lift state up instead of passing data up" — поднимайте состояние, а не передавайте данные наверх через эффекты.
5. "When in doubt, use an event handler" — если вы сомневаетесь, нужен ли эффект, скорее всего, логика должна быть в обработчике события (клика, отправки формы и т.д.).

А теперь - чуть подробнее.

## **10 случаев, когда useEffect не нужен**

### **Слайд 6: 1. Пустые эффекты**

**Плохой пример:**

```javascript
function Component() {
  useEffect(() => {}, []); // Бессмысленный эффект
}
```

Просто удалите его. Если эффект ничего не делает - он не нужен.

### **Слайд 7: 2. Эффекты, которые используют только пропсы**

**Плохой пример:**

```javascript
function Component({ foo }) {
  useEffect(() => {
    console.log(foo);
  }, [foo]);
}
```

Если эффект использует только пропсы и не взаимодействует с внешними системами - скорее всего, эта логика должна быть в родительском компоненте.

**Решение:**
Поднимите логику на уровень выше, где находятся данные.

### **Слайд 8: 3. Производное состояние**

**Плохой пример:**

```javascript
function Form({ firstName, lastName }) {
  const [fullName, setFullName] = useState('');

  useEffect(() => {
    setFullName(firstName + ' ' + lastName);
  }, [firstName, lastName]);
}
```

Здесь мы видим классический пример - вычисление fullName через эффект. Проблема в том, что мы создаем лишний ре-рендер: сначала рендер с пустым fullName, потом эффект, который вызывает обновление состояния и повторный рендер.

**Решение:**

```javascript
function Form({ firstName, lastName }) {
  const fullName = firstName + ' ' + lastName;
}
```

Вычисляйте значения напрямую во время рендера! Если вычисление дорогое - используйте useMemo.

### **Слайд 9: 4. Цепочки обновлений состояния**

**Плохой пример:**

```javascript
// Длинная цепочка эффектов, которые триггерят друг друга
useEffect(() => {
  if (card !== null && card.gold) {
    setGoldCardCount(c => c + 1);
  }
}, [card]);

useEffect(() => {
  if (goldCardCount > 3) {
    setRound(r => r + 1);
    setGoldCardCount(0);
  }
}, [goldCardCount]);
```

Это то, что называется 'эффект-лабиринт'. Каждый эффект запускает следующий, создавая цепочку обновлений. Код становится непредсказуемым и трудноотлаживаемым.

**Решение:**

```javascript
function handleCardPick(nextCard) {
  // Вся логика в одном месте - в обработчике события
  setCard(nextCard);

  if (nextCard.gold) {
    if (goldCardCount <= 3) {
      setGoldCardCount(prev => prev + 1);
    } else {
      setGoldCardCount(0);
      setRound(prev => prev + 1);
    }
  }
}
```

Объединяйте связанные обновления состояния в одном месте (обычно в обработчиках событий).

Пример по-хитрее:

```javascript
useEffect(() => {
  if (user) {
    setProfile(null);
    fetchProfile(user.id).then(setProfile);
  }
}, [user]);

useEffect(() => {
  if (profile) {
    setPosts([]);
    fetchPosts(profile.id).then(setPosts);
  }
}, [profile]);
```

Проблема: Что, если user изменится, пока мы получаем profile? Мы получим profile для старого пользователя, а потом и posts для него же. Race condition налицо.

Решение: Объединяйте логику в событии или используйте async/await для последовательных операций. Для параллельных независимых данных — запрашивайте их одновременно.

### **Слайд 10: 5. Эффект как обработчик событий**

**Плохой пример:**

```javascript
function Form() {
  const [dataToSubmit, setDataToSubmit] = useState();

  useEffect(() => {
    if (dataToSubmit) {
      submitData(dataToSubmit);
    }
  }, [dataToSubmit]);
}
```

Здесь эффект используется как 'наблюдатель' за состоянием. Это антипаттерн! React и так знает, когда состояние меняется - он перерендерит компонент.

**Решение:**

```javascript
function Form() {
  const [dataToSubmit, setDataToSubmit] = useState();

  const handleSubmit = () => {
    submitData(dataToSubmit);
  };
}
```

Выполняйте side-эффекты напрямую в ответ на действия пользователя, а не через наблюдение за состоянием.

### **Слайд 11: 6. Корректировка состояния при изменении пропсов**

**Плохой пример:**

```javascript
function List({ items }) {
  const [selection, setSelection] = useState();

  useEffect(() => {
    setSelection(null);
  }, [items]);
}
```

Эффект, который сбрасывает состояние при изменении пропса - распространенный паттерн, но он не оптимален. Он создает лишний рендер.

**Решение:**

```javascript
// Решение 1: Полностью контролируемый извне
function List({ items, selection, onSelectionChange }) {
  // selection управляется родителем, нам не нужно сбрасывать его внутри
}

// Решение 2: Полностью независимый внутренний state + ключ для сброса
function List({ items }) {
  const [prevItems, setPrevItems] = useState(items);

  if (items !== prevItems) {
    setPrevItems(items);
    setSelection(null);
  }
  
  // Или лучше вообще без состояния:
  const selection = items.find(item => item.id === selectedId) ?? null;
}
```

О ключах для полного сброса компонента мы еще поговорим дальше.

### **Слайд 12: 7. Полный сброс состояния при изменении пропса**

**Плохой пример:**

```javascript
function ProfilePage({ userId }) {
  const [user, setUser] = useState(null);
  const [comment, setComment] = useState('');

  useEffect(() => {
    setUser(null);
    setComment('');
  }, [userId]);
}
```

Когда нужно сбросить все состояние при изменении пропса, не нужно делать это вручную через эффект.

**Решение:**

```javascript
function ProfilePage({ userId }) {
  return <Profile userId={userId} key={userId} />;
}

function Profile({ userId }) {
  // При изменении key компонент полностью пересоздается
  const [comment, setComment] = useState('');
}
```

Используйте key проп - это идиоматический способ сказать React: 'это совершенно другой экземпляр компонента'.

### **Слайд 13: 8. Передача актуального состояния в родитель**

**Плохой пример:**

```javascript
function Toggle({ onChange }) {
  const [isOn, setIsOn] = useState(false);

  useEffect(() => {
    onChange(isOn); // Передача состояния в эффекте
  }, [isOn, onChange]);
}
```

Проблема здесь в том, что родитель получает обновление с задержкой - после рендера и эффекта. Это может привести к рассинхронизации. К тому же, мы заставляем родителя подписываться на изменения, которые ему, возможно, не нужны.

При каждом рендере Toggle (например, из-за родителя) мы вызываем onChange, даже если isOn не менялся. Это может вызвать лавину обновлений.

**Решение:**

```javascript
function Toggle({ onChange }) {
  const [isOn, setIsOn] = useState(false);
  
  function updateToggle(nextIsOn) {
    setIsOn(nextIsOn);
    onChange(nextIsOn); // Сразу уведомляем родителя
  }
}
```

Теперь уведомление происходит только в ответ на действие пользователя, а не на каждый рендер.

Обновляйте состояние и уведомляйте родителя синхронно в одном месте.

### **Слайд 14: 9. Передача данных в родительский компонент**

**Плохой пример:**

```javascript
const Child = ({ onFetched }) => {
  const data = useSomeAPI();

  useEffect(() => {
    onFetched(data);
  }, [onFetched, data]);
};
```

Это нарушает поток данных в React. Данные должны течь сверху вниз, а не снизу вверх через эффекты.

**Решение:**

```javascript
// Получаем данные в родителе и передаем вниз
function Parent() {
  const data = useSomeAPI();

  return <Child data={data} />;
}
```

Поднимите получение данных на уровень выше или используйте контекст для разделения ответственности.

### **Слайд 15: 10. Инициализация состояния в эффекте**

**Плохой пример:**

```javascript
function MyComponent() {
  const [state, setState] = useState();

  useEffect(() => {
    setState("Hello"); // Инициализация в эффекте
  }, []);
}
```

Зачем делать два рендера, когда можно сделать один?

**Решение:**

```javascript
// Простая инициализация
function MyComponent() {
  const [state, setState] = useState("Hello"); // Инициализация сразу
}

// Ленивая инициализация для дорогих вычислений
function ExpensiveComponent() {
  const [state, setState] = useState(() => {
    // Это вычисление выполнится только при первом рендере
    return expensiveCalculation();
  });
}
```

Инициализируйте состояние сразу в useState. Если начальное значение требует дорогих вычислений - используйте ленивую инициализацию через функцию. Это вычисление выполнится только один раз при монтировании компонента, но без лишнего ре-рендера от эффекта.

Ключевое отличие: функция в useState выполняется только при первом рендере, а эффект с пустыми зависимостями выполняется после рендера, вызывая дополнительное обновление состояния и повторный рендер.

### **Слайд 16: Когда useEffect нужен**

Чтобы не сложилось впечатление, что useEffect — это зло, давайте четко обозначим его законные применения.

1. Реакция на изменение пропса/стейта для синхронизации с внешним миром.

```javascript
// Синхронизация с LocalStorage
useEffect(() => {
  localStorage.setItem('theme', theme);
}, [theme]);

// Синхронизация с API браузера (document.title)
useEffect(() => {
  document.title = `${count} new messages`;
}, [count]);
```

2. Подписка на внешние события.

```javascript
useEffect(() => {
  const handleOnline = () => setIsOnline(true);
  window.addEventListener('online', handleOnline);

  return () => window.removeEventListener('online', handleOnline); // или AbortController, signal
}, []);
```

3. Интеграция с не-React библиотеками.

```javascript
useEffect(() => {
  const chart = new ChartJS(ref.current, { ...config, data });

  return () => chart.destroy(); // Важно: очистка!
}, [data]);
```

4. Запрос данных, когда нет возможности использовать более продвинутые инструменты.

```javascript
useEffect(() => {
  let ignore = false; // Защита от race condition

  fetchData().then(data => {
    if (!ignore) setData(data);
  });

  return () => { ignore = true; };
}, [query]);
```

Золотое правило: Если ваш эффект не синхронизирует компонент с какой-либо внешней системой, задайте себе вопрос: "А можно ли это сделать проще?

### **Слайд 17: Что дальше?**

Сегодня мы рассмотрели основные проблемы, которые возникают при неправильном использовании useEffect. И да, эти проблемы могут быть отловлены с помощью линтера. На досуге я набросал ТЗ по внедрении подобного плагина. Мы внедряем ESLint плагин `eslint-plugin-react-you-might-not-need-an-effect`, который автоматически обнаружит эти антипаттерны в нашем коде.

**Как я вижу внедрение:**

1. Сначала добавим правила с уровнем `warn` - чтобы видеть проблемы, но не блокировать разработку (возможно, стоило бы сразу сделать как error, но заглушить имеющиеся ошибки - их 172, но, код из-за лишних комментариев станет сложнее читать, поэтому не пойдем по этому пути).
2. Будем исправлять старые ошибки постепенно, по мере работы с компонентами
3. Для нового кода - задумываться, когда используем useEffect, и сразу писать правильно

**Что это даст:**

- Улучшится производительность - меньше лишних ре-рендеров
- Упростится отладка - код станет более предсказуемым
- Улучшится архитектура - более четкое разделение ответственности"

### **Слайд 18: Заключение**

Помните: useEffect - это инструмент для синхронизации с внешними системами, а не для организации потока данных внутри приложения.

Прежде чем написать useEffect, спросите себя:

1. Можно ли это вычислить во время рендера? -> Вычисляйте в рендере или используйте useMemo.
2. Это реакция на конкретное действие пользователя? -> Используйте обработчик события (onClick, onSubmit).
3. Нужно ли синхронизировать состояние компонента с пропсами? -> Попробуйте сделать состояние полностью контролируемым или используйте key.
4. Это просто 'поток данных' внутри приложения? -> Поднимите состояние выше или используйте контекст.

Давайте вместе сделаем наш код чище, производительнее и понятнее! Спасибо за внимание.

Вопросы?
